{% decl block_generics %}
{% if block.root %}
    {% let block_generics = "<I>" %}
{% else %}
    {% let block_generics = "<'i, I>" %}
{% endif %}

{{ self::description_to_docstring(block.description) }}
#[derive(Debug)]
pub struct {{ block.name.to_case(Case::Pascal) }}{{block_generics}} {
    {% if block.root %}
    pub(crate) interface: I,
    {% else %}
    pub(crate) interface: &'i mut I,
    {% endif %}
    #[doc(hidden)]
    base_address: {{device.internal_address_type}},
}

impl{{block_generics}} {{ block.name.to_case(Case::Pascal) }}{{block_generics}} {
    {% if block.root %}
    /// Create a new instance of the block based on device interface
    pub const fn new(interface: I) -> Self {
        Self { interface, base_address: 0 }
    }

    /// A reference to the interface used to communicate with the device
    pub(crate) fn interface(&mut self) -> &mut I {
        &mut self.interface
    }
    {% else %}
    /// Create a new instance of the block based on device interface
    #[doc(hidden)]
    fn new(interface: &'i mut I, base_address: {{device.internal_address_type}}) -> Self {
        Self { interface, base_address: base_address }
    }

    /// A reference to the interface used to communicate with the device
    pub(crate) fn interface(&mut self) -> &mut I {
        self.interface
    }
    {% endif %}

    {% for method in block.methods %}
        {{ self::description_to_docstring(method.description) }}
        {% match method.repeat %}
            {% when Repeat::None %}
            {% when Repeat::Count { count, .. } %}
            ///
            /// Valid index range: 0..{{count}}
            {% when Repeat::Enum { .. } %}
            {% endwhen %}
        {% endmatch %}
        pub fn {{ method.name.to_case(Case::Snake) }}(
            &mut self,
            {% match method.repeat %}
                {% when Repeat::None %}
                {% when Repeat::Count { .. } %} index: usize
                {% when Repeat::Enum { enum_name, .. } %} index: {{enum_name.to_case(Case::Pascal)}}
            {% endmatch %}
        ) -> 
        {% match method.method_type %}
            {% when BlockMethodType::Block { name } %} {{name.to_case(Case::Pascal)}}<'_, I>
            {% when BlockMethodType::Register { field_set_name, access, address_type, .. } %} ::device_driver::RegisterOperation<'_, I, {{address_type}}, {{field_set_name.to_case(Case::Pascal)}}, ::device_driver::{{access}}>
            {% when BlockMethodType::Command { field_set_name_in, field_set_name_out, address_type } %} ::device_driver::CommandOperation<'_, I, {{address_type}}, {{self::get_command_fieldset_name(field_set_name_in)}}, {{self::get_command_fieldset_name(field_set_name_out)}}>
            {% when BlockMethodType::Buffer { access, address_type } %} ::device_driver::BufferOperation<'_, I, {{address_type}}, ::device_driver::{{access}}>
        {% endmatch %}
        {
            {% match method.repeat %}
                {% when Repeat::None %} let address = self.base_address + {{method.address}};
                {% when Repeat::Count { count, stride } %}
                    let address = {
                        assert!(index < {{count}});
                        self.base_address + {{method.address}} + index as {{device.internal_address_type}} * {{stride}}
                    };
                {% when Repeat::Enum { enum_name, stride, .. } %}
                    let address = self.base_address + {{method.address}} + {{self::get_enum_base_type(driver, &enum_name)}}::from(index) as {{device.internal_address_type}} * {{stride}};
            {% endmatch %}

            {% match method.method_type %}
                {% when BlockMethodType::Block { name } %}
                    {{name.to_case(Case::Pascal)}}::<'_, I>::new(self.interface(), address)
                {% endwhen %}
                {% when BlockMethodType::Register { field_set_name, access, address_type, reset_value } %}
                    ::device_driver::RegisterOperation::<
                        '_,
                        I,
                        {{address_type}},
                        {{field_set_name.to_case(Case::Pascal)}},
                        ::device_driver::{{access}},
                    >::new(
                        self.interface(),
                        address as {{address_type}},
                        {% if let Some(rv) = reset_value %}
                            || {{field_set_name.to_case(Case::Pascal)}}::from([{{rv | join(", ")}}]),
                        {% else %}
                            {{field_set_name.to_case(Case::Pascal)}}::new,
                        {% endif %}
                        )
                {% endwhen %}
                {% when BlockMethodType::Command { field_set_name_in, field_set_name_out, address_type } %}
                    ::device_driver::CommandOperation::<
                        '_,
                        I,
                        {{address_type}},
                        {{self::get_command_fieldset_name(field_set_name_in)}},
                        {{self::get_command_fieldset_name(field_set_name_out)}},
                    >::new(self.interface(), address as {{address_type}})
                {% endwhen %}
                {% when BlockMethodType::Buffer { access, address_type } %}
                    ::device_driver::BufferOperation::<
                        '_,
                        I,
                        {{address_type}},
                        ::device_driver::{{access}},
                    >::new(self.interface(), address as {{address_type}})
                {% endwhen %}
            {% endmatch %}
        }
    {% endfor %}
}