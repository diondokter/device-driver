{{self::description_to_docstring(field_set.description)}}
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct {{field_set.name}} {
    /// The internal bits
    bits: [u8; {{field_set.size_bytes()}}]
}

impl ::device_driver::FieldSet for {{field_set.name}} {
    const SIZE_BITS: u32 = {{field_set.size_bits}};
    fn get_inner_buffer(&self) -> &[u8] {
        &self.bits
    }
    fn get_inner_buffer_mut(&mut self) -> &mut [u8] {
        &mut self.bits
    }
}

impl {{field_set.name}} {
    /// Create a new instance, loaded with all zeroes
    pub const fn new() -> Self {
        Self { bits: [0; {{field_set.size_bytes()}}] }
    }

    {% for field in field_set.fields %}
        {% if matches!(field.access, Access::RW | Access::RO) %}
            ///Read the `{{field.name}}` field of the register.
            ///
            {{self::description_to_docstring(field.description)}}
            pub fn {{field.name}}(
                &self,
                {% match field.repeat %}
                    {% when Repeat::None %}
                    {% when Repeat::Count { .. } %} index: usize
                    {% when Repeat::Enum { enum_name, .. } %} index: {{enum_name}}
                {% endmatch %}
            ) -> 
                {% match field.conversion_method %}
                    {% when FieldConversionMethod::None %} {{field.base_type}}
                    {% when FieldConversionMethod::Into(t) | FieldConversionMethod::UnsafeInto(t) %} {{t}}
                    {% when FieldConversionMethod::TryInto(t) %} Result<{{t}}, <{{t}} as TryFrom<{{field.base_type}}>>::Error>
                    {% when FieldConversionMethod::Bool %} bool
                {% endmatch %}
            {
                {% match field.repeat %}
                    {% when Repeat::None %}
                    let start = {{field.address.start}};
                    let end = {{field.address.end}};
                    {% when Repeat::Count { count, stride } %}
                    assert!(index < {{count}});
                    let start = {{field.address.start}} + index * {{stride}};
                    let end = start + {{field.address.len()}};
                    {% when Repeat::Enum { enum_name, stride, .. } %}
                    let start = {{field.address.start}} + {{self::get_enum_base_type(device, &enum_name)}}::from(index) as usize * {{stride}};
                    let end = start + {{field.address.len()}};
                {% endmatch %}

                let raw = unsafe {
                    ::device_driver::ops::load_{{field_set.bit_order | lower}}::<
                        {{field.base_type}},
                        ::device_driver::ops::{{field_set.byte_order}},
                    >(&self.bits, start, end)
                };

                {% match field.conversion_method %}
                    {% when FieldConversionMethod::None %} raw
                    {% when FieldConversionMethod::Into(t) %} raw.into()
                    {% when FieldConversionMethod::UnsafeInto(t) %} unsafe { raw.try_into().unwrap_unchecked() }
                    {% when FieldConversionMethod::TryInto(t) %} raw.try_into()
                    {% when FieldConversionMethod::Bool %} raw > 0
                {% endmatch %}
            }
        {% endif %}
    {% endfor %}

    {% for field in field_set.fields %}
        {% if matches!(field.access, Access::RW | Access::WO) %}
            ///Write the `{{field.name}}` field of the register.
            ///
            {{self::description_to_docstring(field.description)}}
            pub fn set_{{field.name}}(
                &mut self,
                value: {% match field.conversion_method %}
                    {% when FieldConversionMethod::None %} {{field.base_type}}
                    {% when FieldConversionMethod::Into(t) %} {{t}}
                    {% when FieldConversionMethod::UnsafeInto(t) %} {{t}}
                    {% when FieldConversionMethod::TryInto(t) %} {{t}}
                    {% when FieldConversionMethod::Bool %} bool
                {% endmatch %}
            ) {
                let raw = 
                {% match field.conversion_method %}
                    {% when FieldConversionMethod::None %} value;
                    {% when FieldConversionMethod::Bool %} value as _;
                    {% else %} value.into();
                {% endmatch %}

                unsafe {
                    ::device_driver::ops::store_{{field_set.bit_order | lower}}::<
                        {{field.base_type}},
                        ::device_driver::ops::{{field_set.byte_order}},
                    >(raw, {{field.address.start}}, {{field.address.end}}, &mut self.bits)
                };
            }
        {% endif %}
    {% endfor %}
}

impl Default for {{field_set.name}} {
    fn default() -> Self {
        Self::new()
    }
}

impl From<[u8; {{field_set.size_bytes()}}]> for {{field_set.name}} {
    fn from(bits: [u8; {{field_set.size_bytes()}}]) -> Self {
        Self { bits }
    }
}

impl From<{{field_set.name}}> for [u8; {{field_set.size_bytes()}}] {
    fn from(val: {{field_set.name}}) -> Self {
        val.bits
    }
}

impl core::fmt::Debug for {{field_set.name}} {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> Result<(), core::fmt::Error> {
        let mut d = f.debug_struct("{{field_set.name}}");
        {% for field in field_set.fields %}
            {% if field.access.is_readable() %}
                {% match field.repeat %}
                    {% when Repeat::None %}
                        d.field("{{field.name}}", &self.{{field.name}}());
                    {% when Repeat::Count { count, .. } %}
                        {% for index in 0..*count %}
                            d.field("{{field.name}}[{{index}}]", &self.{{field.name}}({{index}}));
                        {% endfor %}
                    {% when Repeat::Enum { enum_name, enum_variants, .. } %}
                        {% for variant in enum_variants %}
                            d.field("{{field.name}}[{{variant}}]", &self.{{field.name}}({{enum_name}}::{{variant}}));
                        {% endfor %}
                {% endmatch %}
            {% endif %}
        {% endfor %}
        d.finish()
    }
}

{% if let Some(defmt_feature) = device.defmt_feature %}
#[cfg(feature = "{{defmt_feature}}")]
impl defmt::Format for {{field_set.name}} {
    fn format(&self, f: defmt::Formatter) {
        defmt::write!(f, "{{field_set.name}} {% raw %}{{{% endraw %} ");

        {% for field in field_set.fields %}
            {% if field.access.is_readable() %}
                {% match field.repeat %}
                    {% when Repeat::None %}
                        defmt::write!(f, "{{self::get_defmt_fmt_string(field)}}", &self.{{field.name}}());
                    {% when Repeat::Count { count, .. } %}
                        {% for index in 0..*count %}
                            defmt::write!(f, "{{self::get_defmt_fmt_string(field)}}[{{index}}]", &self.{{field.name}}({{index}}));
                        {% endfor %}
                    {% when Repeat::Enum { enum_name, enum_variants, .. } %}
                        {% for variant in enum_variants %}
                            defmt::write!(f, "{{self::get_defmt_fmt_string(field)}}[{{variant}}]", &self.{{field.name}}({{enum_name}}::{{variant}}));
                        {% endfor %}
                {% endmatch %}
            {% endif %}
        {% endfor %}

        defmt::write!(f, "{% raw %}}}{% endraw %}");
    }
}
{% endif %}

impl core::ops::BitAnd for {{field_set.name}} {
    type Output = Self;
    fn bitand(mut self, rhs: Self) -> Self::Output {
        self &= rhs;
        self
    }
}
impl core::ops::BitAndAssign for {{field_set.name}} {
    fn bitand_assign(&mut self, rhs: Self) {
        for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
            *l &= *r;
        }
    }
}
impl core::ops::BitOr for {{field_set.name}} {
    type Output = Self;
    fn bitor(mut self, rhs: Self) -> Self::Output {
        self |= rhs;
        self
    }
}
impl core::ops::BitOrAssign for {{field_set.name}} {
    fn bitor_assign(&mut self, rhs: Self) {
        for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
            *l |= *r;
        }
    }
}
impl core::ops::BitXor for {{field_set.name}} {
    type Output = Self;
    fn bitxor(mut self, rhs: Self) -> Self::Output {
        self ^= rhs;
        self
    }
}
impl core::ops::BitXorAssign for {{field_set.name}} {
    fn bitxor_assign(&mut self, rhs: Self) {
        for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
            *l ^= *r;
        }
    }
}
impl core::ops::Not for {{field_set.name}} {
    type Output = Self;
    fn not(mut self) -> Self::Output {
        for val in self.bits.iter_mut() {
            *val = !*val;
        }
        self
    }
}
