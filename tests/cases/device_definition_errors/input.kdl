a 1

device {

}

device 1 {

}

device FooD0 {

}

device FooD1 abc def {

}

device FooD2 {
    blah 123
}

device FooD3 {
    register-access RW
    register-access RO
}

device FooD4 {
    register-access Blah
    buffer-access
    field-access RW RO WO
}

device FooD5 {
    register-access value=RW
    register-address-type u8
    command-address-type 16
    bit-order msb0
    defmt-feature lol
    name-word-boundaries aA:1a
}

/// Comments here :D
device FooD6 {
    register-address-type u8
    command-address-type u8
    buffer-address-type u8

    registah
    register
    register foor1 {

    }
    register foor2 {
        address
        address a
        address 1
        address 2
        repeat
        reset-value 0x2000_0000
    }
    register foor3 {
        address -1
        repeat count=18_446_744_073_709_551_616 stride=1
        allow-address-overlap #true
        reset-value 0x100 0x00
    }
    register foor4 {
        address 0
        fields {

        }
    }
    register foor5 {
        address 1
        fields size-bits=-1 {

        }
    }
    register foor6 {
        address 2
        fields size-bits=0x1_0000_0000 byte-order=BLA byte-order=BE bit-order=gkd bit-order=msb0 allow-bit-overlap allow-bit-overlap=#false {

        }
    }
    register foor7 {
        address 3
        fields size-bits=0x1_0000_0000 byte-order=1 bit-order=#true allow-bit-overlap  {

        }
    }
    /// Hello!
    register foor8 {
        address 4
        /// This fieldset has a custom name
        fields CustomFieldSetName size-bits=8 {
            bar RW RO
            bar @a @-1:8 @3 @3:0
            baz @7:4 blah
        }
    }
    register foor9 {
        address 5
        fields size-bits=8 {
            (bool)bar @0
            (uint)baz @2:1
            (i16a)quux @4:3
            (i32:e3?)qus @6:5
        }
    }
    register foor10 {
        address 6
        repeat with=Foo10E1 stride=2
        fields size-bits=8 {
            (u16:Foo10E1)bar @1:0 {
                A 0
                B 1
                C default
                D 3
            }
            baz @3:2 {

            }
            (uint)bam @5:4 {

            }
            (:Foo10E2?)bat @7:6 {
                A
                B 1.0
                C value
                D #null 2
            }
        }
    }
    command {

    }
    command fooc0 {

    }
    command fooc1 {
        address 0
        repeat
        blah
        in {

        }
        out size-bits=8 {
            b @0
            c @1:2
        }
    }
    buffer {

    }
    buffer foob0 {

    }
    buffer foob1 {
        address 0
        addressssss 500
        address 1
    }
    buffer foob2 {
        address 2
        access BLAH
        access RO
    }
    block
    /// This is a block
    block b1 {
        foo
        offset d
        offset 5
        offset 20
    }
    block b2 {
        repeat
        repeat count=2 stride=4

        buffer b2foo {
            address 42
        }
    }
    fieldset
    fieldset fs1 size-bits=16 byte-order=LE {
        value @15:0
    }
    enum
    enum e1 {
        A
        B 1.0
        C value
        D #null 2
    }
    enum e2 size-bits=1 {
        A
        B
    }
    /// You can document enums too!
    (i32)enum e3 {
        A
        /// Wow, it's a B!
        B
    }
    extern
    (i16:something?)extern etype1 a
    /// Some docs over here!
    (u8)extern etype2 infallible
    (u8)extern etype3
    fieldset fs2 size-bits=32 byte-order=LE {
        (:etype2)value @6:0
        (:etype3?)value2 @10:7
    }
    fieldset fs3 size-bits=32 byte-order=LE {
        val0 @1:0 with=e3
        val1 @3:2 with=e3 stride=2
        val2 @7:6 count=4 stride=2
        val3 @15:14 stride=0
    }
}
